\chapter{Basics of the Julia Language}

In this chapter, we cover how we can do most common tasks for computing in operations research and management science with the Julia Language. While I will cover some part of the syntax of \julia{}, readers must consult with the \href{http://docs.julialang.org/}{official documentation}\footnote{\url{http://docs.julialang.org/}} of \julia{} for other unexplained usages.


\section{Vector, Matrix, and Array}

Like \matlab{} and many other computer languages for numerical computation, \julia{} provides easy and convenient, but strong, ways of handling vectors and matrices. For example, if you want to create vectors and matrices like
\[
\vect{a} = \begin{bmatrix} 1\\2\\3 \end{bmatrix}, \qquad \vect{b} = \begin{bmatrix} 4 & 5 & 6 \end{bmatrix}, \qquad \mat{A} = \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}
\]
then in \julia{}, you can simply type
%= lang:julia
\begin{code}
a = [1; 2; 3]
b = [4 5 6]
A = [1 2 3; 4 5 6]
\end{code}
\noindent where the semicolon (;) means a new row. \julia{} will return:
%= lang:julia
\begin{code}
julia> a = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> b = [4 5 6]
1x3 Array{Int64,2}:
 4  5  6

julia> A = [1 2 3; 4 5 6]
2x3 Array{Int64,2}:
 1  2  3
 4  5  6
\end{code}
\noindent We can access the $(i,j)$-element of $\mat{A}$ by \kode{A[i,j]}:
%= lang:julia
\begin{code}
julia> A[1,3]
3

julia> A[2,1]
4
\end{code}



The transpose of vectors and matrices is easily obtained either of the following codes:
%= lang:julia
\begin{code}
julia> transpose(A)
3x2 Array{Int64,2}:
 1  4
 2  5
 3  6

julia> A'
3x2 Array{Int64,2}:
 1  4
 2  5
 3  6
\end{code}



Let us introduce two column vectors:
%= lang:julia
\begin{code}
a = [1; 2; 3]
c = [7; 8; 9]
\end{code}
\noindent The inner product, or dot product, may be obtained by the following two ways:
%= lang:julia
\begin{code}
a'*c
dot(a,c)
\end{code}
\noindent The results, however, are different:
%= lang:julia
\begin{code}
julia> a'*c
1-element Array{Int64,1}:
 50

julia> dot(a,c)
50
\end{code}
\noindent Note that \kode{a'*c} results in an Array object, while \kode{dot(a,c)} simply gives a scalar value.

Many functions of \julia{} for handling vectors and matrices are similar to those of \matlab{}. The identity matrices of certain sizes:
%= lang:julia
\begin{code}
julia> eye(2)
2x2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia> eye(3)
3x3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{code}
\noindent The matrices of zeros and ones of custom sizes:
%= lang:julia
\begin{code}
julia> zeros(4,1)
4x1 Array{Float64,2}:
 0.0
 0.0
 0.0
 0.0

julia> zeros(2,3)
2x3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> ones(1,3)
1x3 Array{Float64,2}:
 1.0  1.0  1.0

julia> ones(3,2)
3x2 Array{Float64,2}:
 1.0  1.0
 1.0  1.0
 1.0  1.0
\end{code}

When we have a square matrix
%= lang:julia
\begin{code}
julia> B = [1 3 2; 3 2 2; 1 1 1]
3x3 Array{Int64,2}:
 1  3  2
 3  2  2
 1  1  1
\end{code}
\noindent its inverse can be computed:
%= lang:julia
\begin{code}
julia> inv(B)
3x3 Array{Float64,2}:
  0.0   1.0  -2.0
  1.0   1.0  -4.0
 -1.0  -2.0   7.0
\end{code}
\noindent Of course, there are some numerical errors:
%= lang:julia
\begin{code}
julia> B * inv(B)
3x3 Array{Float64,2}:
 1.0  8.88178e-16  -3.55271e-15
 0.0  1.0           0.0
 0.0  2.22045e-16   1.0
\end{code}
\noindent Note that the off-diagonal elements are not exactly zero. This is because the computation of the inverse matrix is not exact. For example, the (2,1)-element of the inverse matrix is not exactly 1, but:
%= lang:julia
\begin{code}
julia> inv(B)[2,1]
1.0000000000000002
\end{code}




In the above, we have seen something like \kode{Int64} and \kode{Float64}. In 32-bit systems, it would have been \kode{Int32} and \kode{Float32}. These are data types. If the elements in your vectors and matrices are integers for sure, you can use \kode{Int64}. On the other hand, if any element is non-integer values, such as $1.0000000000000002$, you need to use \kode{Float64}. These are usually done automatically:
%= lang:julia
\begin{code}
julia> a = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> b = [1.0; 2; 3]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0
\end{code}

In some cases, you will want to first create an array object of a certain type, then assign values. This can be done by calling \kode{Array}. For example, if we want an array of \kode{Float64} data type and of size 3, then we can do:
%= lang:julia
\begin{code}
julia> d = Array(Float64, 3)
3-element Array{Float64,1}:
 2.24759e-314
 6.9365e-310
 6.9365e-310
\end{code}
\noindent Some random values that are close to zero are pre-assigned. Now you can assign the value you want:
%= lang:julia
\begin{code}
julia> d[1] = 1
1

julia> d[2] = 2
2

julia> d[3] = 3
3

julia> d
3-element Array{Float64,1}:
 1.0
 2.0
 3.0
\end{code}
\noindent Although you entered the exact integer values, the resulting array is of \kode{Float64} type.

If your array represents a vector or a matrix, I recommend you to create an array by explicitly specifying the dimension. For a 3-by-1 column vector, you have to do:
%= lang:julia
\begin{code}
f = Array(Float64, 3, 1)
\end{code}
\noindent and for a 1-by-3 row vector, you have to do:
%= lang:julia
\begin{code}
g = Array(Float64, 1, 3)
\end{code}
\noindent so that the product can be written as \kode{f*g} or \kode{g*f}.


For more information on functions related to arrays, please refer to \href{http://docs.julialang.org/en/stable/stdlib/arrays/}{the official document}.\footnote{\url{http://docs.julialang.org/en/stable/stdlib/arrays/}}



\section{Tuple}

The data type of arrays can be a pair of data types. For example, if we want to store (1,2), (2,3), and (3,4) in an array, we can create an array of type \kode{(Int64, Int64)}.
%= lang:julia
\begin{code}
julia> pairs = Array(Tuple{Int64, Int64}, 3)
3-element Array{Tuple{Int64,Int64},1}:
 (8589934594,2147483649)
 (0,0)
 (0,0)

julia> pairs[1] = (1,2)
(1,2)

julia> pairs[2] = (2,3)
(2,3)

julia> pairs[3] = (3,4)
(3,4)

julia> pairs
3-element Array{Tuple{Int64,Int64},1}:
 (1,2)
 (2,3)
 (3,4)
\end{code}
\noindent This is same as:
%= lang:julia
\begin{code}
julia> pairs = [ (1,2); (2,3); (3,4) ]
3-element Array{(Int64,Int64),1}:
 (1,2)
 (2,3)
 (3,4)
\end{code}
\noindent This type of arrays can be useful for handling network data with nodes and links, for example for storing data like $(i,j)$. When you want $(i,j,k)$, simply do:
%= lang:julia
\begin{code}
julia> ijk_array = Array(Tuple{Int64, Int64, Int64}, 3)
3-element Array{Tuple{Int64,Int64,Int64},1}:
 (4490289104,4490289232,4469175088)
 (4490289360,0,0)
 (0,0,0)

julia> ijk_array[1] = (1,4,2)
(1,4,2)

...
\end{code}




\section{Indices and Ranges}

When we are dealing with indices of arrays---vectors, matrices, or any other arrays---a range will be useful. If we want a set of indices from 1 to 9, we can simply do \kode{1:9}. If we want steps of 2, we do \kode{1:2:9}. Suppose we have a vector $a$:
%= lang:julia
\begin{code}
julia> a = [10; 20; 30; 40; 50; 60; 70; 80; 90]
9-element Array{Int64,1}:
 10
 20
 30
 40
 50
 60
 70
 80
 90
\end{code}
\noindent If we want the first three elements, we can do:
%= lang:julia
\begin{code}
julia> a[1:3]
3-element Array{Int64,1}:
 10
 20
 30
\end{code}
\noindent Some other examples:
%= lang:julia
\begin{code}
julia> a[1:3:9]
3-element Array{Int64,1}:
 10
 40
 70
\end{code}
\noindent where \kode{1:3:9} refers to 1, 4, and 7. Although we specified 9 in \kode{1:3:9}, it didn't reach 9.

The last index can be accessed by using a special keyword \kode{end}. The last three elements can be accessed by:
%= lang:julia
\begin{code}
julia> a[end-2:end]
3-element Array{Int64,1}:
 70
 80
 90
\end{code}

We can also assign some values using a range:
%= lang:julia
\begin{code}
julia> b = [200; 300; 400]
3-element Array{Int64,1}:
 200
 300
 400

julia> a[2:4] = b
3-element Array{Int64,1}:
 200
 300
 400

julia> a
9-element Array{Int64,1}:
  10
 200
 300
 400
  50
  60
  70
  80
  90
\end{code}

We can also use ranges to define an array. Just wrap a range by brackets:
%= lang:julia
\begin{code}
julia> c = [1:2:9]
5-element Array{Int64,1}:
 1
 3
 5
 7
 9
\end{code}

Suppose we have a matrix $\mat{A}$:
%= lang:julia
\begin{code}
julia> A= [1 2 3; 4 5 6; 7 8 9]
3x3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9
\end{code}
\noindent The second column of $\mat{A}$ can be accessed by:
%= lang:julia
\begin{code}
julia> A[:,2]
3-element Array{Int64,1}:
 2
 5
 8
\end{code}
\noindent and the third row can be accessed by:
%= lang:julia
\begin{code}
julia> A[3,:]
1x3 Array{Int64,2}:
 7  8  9
\end{code}






\section{Printing Messages}

Displaying messages on the screen is the simplest tool for debugging and checking the computational results. This section introduces functions related to displaying and printing messages.

The most frequently used printing function would be \kode{println} and \kode{print}. We can simply do:
%= lang:julia
\begin{code}
julia> println("Hello World")
Hello World
\end{code}
\noindent The difference between the two functions is that \kode{println} adds an empty line after it.
%= lang:julia
\begin{code}
julia> print("Hello "); print("World"); print(" Again")
Hello World Again
julia> println("Hello "); println("World"); println(" Again")
Hello
World
 Again

julia>
\end{code}

Combining the custom text with values in a variable is easy:
%= lang:julia
\begin{code}
julia> a = 123.0
123.0

julia> println("The value of a = ", a)
The value of a = 123.0

julia> println("a is $a, and a-10 is $(a-10).")
a is 123.0, and a-10 is 113.0.
\end{code}
\noindent It works for arrays:
%= lang:julia
\begin{code}
julia> b = [1; 3; 10]
3-element Array{Int64,1}:
  1
  3
 10

julia> println("b is $b.")
b is [1,3,10].

julia> println("The second element of b is $(b[2]).")
The second element of b is 3.
\end{code}

More advanced functionalities are provided by the \kode{@printf} macro, which uses the style of \kode{printf()} of \kode{C}. Here is an example:
%= lang:julia
\begin{code}
@printf("The %s of a = %f", "value", a)
The value of a = 123.000000
\end{code}
\noindent The first argument is the format specification: it involves a string with symbols like \kode{\%s} and \kode{\%f}. In the format specification, \kode{\%s} is a placeholder for a string like \kode{"value"}, and \kode{\%f} is a placeholder for a floating number like \kode{a}. The placeholder for an integer is \kode{\%d}.

The \kode{@printf} macro is very useful, when we want to print a series of numbers whose digit number differ, but we want to give some good alignment options. Suppose
%= lang:julia
\begin{code}
c = [ 123.12345   ;
       10.983     ;
        1.0932132  ]
\end{code}
\noindent If we just use \kode{println}, we obtain:
%= lang:julia
\begin{code}
julia> for i in 1:length(c)
           println("c[$i] = $(c[i])")
       end
c[1] = 123.12345
c[2] = 10.983
c[3] = 1.0932132
\end{code}
\noindent Not so pretty. Use \kode{@printf}:
%= lang:julia
\begin{code}
julia> for i in 1:length(c)
           @printf("c[%d] = %7.3f\n", i, c[i])
       end
c[1] = 123.123
c[2] =  10.983
c[3] =   1.093
\end{code}
\noindent where \kode{\%7.3} indicates that we want the total number of digits to be 7 (including the decimal point) and the number of digits below the decimal point to be 3. In addition \kode{\textbackslash n} means a new line.

There is another macro called \kode{@sprintf}, which is basically same as \kode{@printf}, but it returns a string, instead of printing it on the screen. For example:
%= lang:julia
\begin{code}
julia> str = @sprintf("The %s of a = %f", "value", a)
julia> println(str)
The value of a = 123.000000
\end{code}

For more format specifiers, see \url{http://www.cplusplus.com/reference/cstdio/printf/}.






\section{Collection, Dictionary, and For-Loop}

When we repeat a similar job for multiple times, we use a for-loop. For example:
%= lang:julia
\begin{code}
julia> for i in 1:5
           println("This is number $i.")
       end
This is number 1.
This is number 2.
This is number 3.
This is number 4.
This is number 5.
\end{code}
A for-loop has a structure of
%= lang:julia
\begin{code}
for i in I
	# do something here for each i
end
\end{code}
\noindent where \kode{I} is a \emph{collection}. The most common collection type in computing is a range, like \kode{1:5} in the above example.

If you want to stop at a certain point, you can \kode{break} the loop:
%= lang:julia
\begin{code}
julia> for i in 1:5
           if i >= 3
               break
           end
           println("This is number $i.")
       end
This is number 1.
This is number 2.
\end{code}

If we want to compute the sum of all elements in vector $a$, then we can do the following:
%= lang:julia
\begin{code}
s = 0
for i in 1:length(a)
	s += a[i]
end
\end{code}
\noindent where \kode{s += a[i]} is same as \kode{s = s + a[i]}. By the way, it can be also done by a simple function \kode{sum(a)}.

Another very useful collection type is \emph{Dictionary}. A dictionary has keys and values. For example, suppose we have the following keys and values:
%= lang:julia
\begin{code}
my_keys = ["Zinedine Zidane", "Magic Johnson", "Yuna Kim"]
my_values = ["football", "basketball", "figure skating"]
\end{code}
\noindent We can create a dictionary:
%= lang:julia
\begin{code}
julia> d = Dict()
Dict{Any,Any} with 0 entries

julia> for i in 1:length(my_keys)
           d[my_keys[i]] = my_values[i]
       end

julia> d
Dict{Any,Any} with 3 entries:
  "Magic Johnson"   => "basketball"
  "Zinedine Zidane" => "football"
  "Yuna Kim"        => "figure skating"
\end{code}
\noindent When we use a dictionary, the order of elements saved in the dictionary should not be important. Note in the dictionary \kode{d}, the order is not same as the order in \kode{k} and \kode{v}. If the order is important, we have to be careful with dictionaries.

Using the dictionary \kode{d} defined above, we can for example do something like:
%= lang:julia
\begin{code}
julia> for (key, value) in d
       	println("$key is a $value player.")
       end
Magic Johnson is a basketball player.
Zinedine Zidane is a football player.
Yuna Kim is a figure skating player.
\end{code}

We can also add a new element by:
%= lang:julia
\begin{code}
julia> d["Diego Maradona"] = "football"
"football"

julia> d
Dict{Any,Any} with 4 entries:
  "Magic Johnson"   => "basketball"
  "Zinedine Zidane" => "football"
  "Diego Maradona"  => "football"
  "Yuna Kim"        => "figure skating"
\end{code}

For a network, suppose we have the following data:
%= lang:julia
\begin{code}
links = [ (1,2), (3,4), (4,2) ]
link_costs = [ 5, 13, 8 ]
\end{code}
\noindent We can create a dictionary for this data:
%= lang:julia
\begin{code}
julia> link_dict = Dict()
Dict{Any,Any} with 0 entries

julia> for i in 1:length(links)
           link_dict[ links[i] ] = link_costs[i]
       end

julia> link_dict
Dict{Any,Any} with 3 entries:
  (1,2) => 5
  (4,2) => 8
  (3,4) => 13
\end{code}
\noindent Then we can use it as follows:
%= lang:julia
\begin{code}
julia> for (link, cost) in link_dict
           println("Link $link has cost of $cost.")
       end
Link (1,2) has cost of 5.
Link (4,2) has cost of 8.
Link (3,4) has cost of 13.
\end{code}

For more information on collection and dictionary, please refer to \href{http://docs.julialang.org/en/stable/stdlib/collections/}{the official document}\footnote{\url{http://docs.julialang.org/en/stable/stdlib/collections/}}. There are many convenient functions available.

Sometimes \kode{while}-loops are more useful than \kode{for}-loops. For the usage of \kode{while}-loops and other flow controls, see \href{http://docs.julialang.org/en/stable/manual/control-flow/}{the official document}\footnote{\url{http://docs.julialang.org/en/stable/manual/control-flow/}}.




\section{Function}

Just like any mathematical function, functions in \julia{} accept inputs and return outputs. Consider a simple mathematical function:
\[
	f(x,y) = 3x + y
\]
We can create a \julia{} function for this as follows:
%= lang:julia
\begin{code}
function f(x,y)
	return 3x +y
end
\end{code}
\noindent Simple. Call it:
%= lang:julia
\begin{code}
julia> f(1,3)
6

julia> 3 * ( f(3,2) + f(5,6) )
96
\end{code}

Alternatively, you can define the same function in more compact form, called ``assignment form'':
%= lang:julia
\begin{code}
julia> f(x,y) = 3x+y
f (generic function with 1 method)

julia> f(1,3)
6
\end{code}

Functions can have multiple return values. For example:
%= lang:julia
\begin{code}
function my_func(n, m)
	a = zeros(n,1)
	b = ones(m,1)
	return a, b
end
\end{code}
\noindent We can receive return values as follows:
%= lang:julia
\begin{code}
julia> x, y = my_func(3,2)
(
3x1 Array{Float64,2}:
 0.0
 0.0
 0.0,

2x1 Array{Float64,2}:
 1.0
 1.0)

julia> x
3x1 Array{Float64,2}:
 0.0
 0.0
 0.0

julia> y
2x1 Array{Float64,2}:
 1.0
 1.0
\end{code}

More details are found in \href{http://docs.julialang.org/en/stable/manual/functions/}{the official document}\footnote{\url{http://docs.julialang.org/en/stable/manual/functions/}}.






\section{Scope of Variables} \label{sec:scope}

In any programming language, it is important to understand what variables can be accessed where. Let's consider the following code:
%= lang:julia
\begin{code}
function f(x)
    return x+2
end

function g(x)
    return 3x+3
end
\end{code}
\noindent In this code, although the same variable name \kode{x} is used in two different functions, the two \kode{x} variables do not conflict. It is because they are defined in different \emph{scope blocks}. Examples of scope blocks are \kode{function} bodies, \kode{for} loops, and \kode{while} loops.

When a variable is defined or first introduced, the variable is accessible within the scope block and its sub scope blocks. As an example, consider a script file with the following code:
%= lang:julia
\begin{code}
function f(x)
    return x+a
end

for i in 1:10
    a = i
    println(f(1))
end
\end{code}
\noindent This will generate an error. The \kode{a} variable was first defined within the for-loop scope block, while the function, a separate scope block, requires the value of \kode{a}. To fix this problem, we should define or introduce first the \kode{a} variable in the \emph{parent} scope block, which is outside the for-loop. A revised code is:
%= lang:julia
\begin{code}
function f(x)
    return x+a
end

a = 0
for i in 1:10
    a = i
    println(f(1))
end
\end{code}
\noindent which generates:
%= lang:julia
\begin{code}
2
3
4
5
6
7
8
9
10
11
\end{code}

Let's consider another example.
%= lang:julia
\begin{code}
function f(x)
    a = 0
    return x+a
end

a = 5
println(f(1))
println(a)
\end{code}
\noindent What will be the printed values of \kode{f(1)} and \kode{a}? Quite confusing. If you can avoid codes like the above example, I think it will be the best. The same \kode{a} variable name is used in two different places, and it can be quite confusing sometimes. It may lead to serious bugs in your codes. The result of the above example is:
%= lang:julia
\begin{code}
1
5
\end{code}

To better control the scope of variables, we can use keywords like \kode{global}, \kode{local}, and \kode{const}. I---who usually write short codes for algorithm implementations and optimization modeling---think it is best to avoid same variables names in two different code blocks.

Some would write the above example as follows:
%= lang:julia
\begin{code}
function f(x)
    _a = 0
    return x + _a
end

a = 5
println(f(1))
println(a)
\end{code}
\noindent where the underscore in front of \kode{a} indicates it is a local variable.

Some others would write the above example as follows:
%= lang:julia
\begin{code}
function f(x, a)
    return x + a
end

a = 5
println(f(1, a))
println(a)
\end{code}
\noindent which makes it clear that \kode{a} is a function argument passed from outside the function block.

For more detailed explanation and more examples, please consult with \href{http://docs.julialang.org/en/stable/manual/variables-and-scoping/}{the official documentation}\footnote{\url{http://docs.julialang.org/en/stable/manual/variables-and-scoping/}}.




\section{Random Number Generation}

In scientific computation, we often need to generate random numbers. Monte Carlo Simulation is such a case. We can generate a random number from the uniform distribution between 0 and 1 by simply calling \kode{rand()}:
%= lang:julia
\begin{code}
julia> rand()
0.8689474478700132

julia> rand()
0.33488929348173135
\end{code}
\noindent The generate number will be different for each call.

We can also create a vector of random numbers, for example of size 5:
%= lang:julia
\begin{code}
julia> rand(5)
5-element Array{Float64,1}:
 0.848729
 0.18833
 0.591469
 0.59092
 0.0262999
\end{code}
\noindent or a matrix of random numbers, for example of size 4 by 3:
%= lang:julia
\begin{code}
julia> rand(4,3)
4x3 Array{Float64,2}:
 0.34406    0.335058   0.261013
 0.34656    0.488157   0.600716
 0.0110059  0.0919956  0.501252
 0.894159   0.301035   0.4308
\end{code}

Random numbers from Uniform$[0,100]$:
%= lang:julia
\begin{code}
rand() * 100
\end{code}
\noindent A vector of $n$ random numbers from Uniform$[a,b]$:
%= lang:julia
\begin{code}
rand(n) * (b-a) + a
\end{code}

We can also use \kode{rand} for choosing an index randomly from a range:
%= lang:julia
\begin{code}
julia> rand(1:10)
8

julia> rand(1:10)
2
\end{code}

Similarly, \julia{} provides a function called \kode{randn} for the standard Normal distribution with mean 0 and standard deviation 1, or $N(0,1)$.
%= lang:julia
\begin{code}
julia> randn(2,3)
2x3 Array{Float64,2}:
  2.31415   -0.309773  -0.0174724
 -0.316515   0.514558  -1.53451
\end{code}
\noindent To generate 10 random numbers from a general Normal distribution $N(\mu, \sigma^2)$:
%= lang:julia
\begin{code}
julia> randn(10) * sigma + mu
10-element Array{Float64,1}:
 52.2694
 51.4202
 45.4651
 51.9061
 51.1799
 47.272
 47.585
 48.4993
 54.2316
 46.5286
\end{code}
\noindent where \kode{mu=50} and \kode{sigma=3} are used.

Perhaps, we can write our own function for $N(\mu, \sigma^2)$:
%= lang:julia
\begin{code}
function my_randn(n, mu, sigma)
	return randn(n) * sigma + mu
end
\end{code}
\noindent and call it:
%= lang:julia
\begin{code}
julia> my_randn(10, 50, 3)
10-element Array{Float64,1}:
 48.0865
 47.7267
 47.3458
 48.2318
 53.5715
 54.3249
 53.3419
 46.0114
 49.7636
 56.0803
\end{code}

For any other advanced usages related to probabilistic distributions, the \kode{StatsFuns} package is available from the \href{http://juliastats.org/}{Julia Statistics group}\footnote{\url{http://juliastats.org/}}. We need to first install the package:
%= lang:julia
\begin{code}
julia> Pkg.update()
INFO: Updating METADATA...
...

julia> Pkg.add("StatsFuns")
INFO: Installing StatsFuns v0.1.4
INFO: Package database updated
\end{code}

To use functions available in the \kode{StatsFuns} package, we first load the package:
%= lang:julia
\begin{code}
julia> using StatsFuns
\end{code}
\noindent For a Normal distribution with $\mu=50$ and $\sigma=3$, we set:
%= lang:julia
\begin{code}
julia> mu = 50; sigma = 3;
\end{code}
\noindent The probability density function (PDF) value evaluated at 52:
%= lang:julia
\begin{code}
julia> normpdf(mu, sigma, 52)
0.10648266850745075
\end{code}
\noindent The cumulative distribution function (CDF) value evaluated at 50:
%= lang:julia
\begin{code}
julia> normcdf(mu, sigma, 50)
0.5
\end{code}
\noindent The inverse of CDF for probability 0.5:
%= lang:julia
\begin{code}
julia> norminvcdf(mu, sigma, 0.5)
50.0
\end{code}

For many other probability distributions such as Binomial, Gamma, and Poisson distributions, similar functions are available from \href{https://github.com/JuliaStats/StatsFuns.jl}{the \kode{StatsFuns.jl} package}\footnote{\url{https://github.com/JuliaStats/StatsFuns.jl}}.











\section{File Input/Output} \label{sec:file_io}

A typical flow of computing in operations research, or any other computational sciences, is to read data from files, to run some computations, and to write the results on an output files for records. File read/write or input/output (I/O) is a very useful and important process.
Suppose we have a data file named \kode{data.txt} that looks like:
\begin{codelisting}
\codecaption{\filepath{code/chap3/data.txt}}
%= <<(code/chap3/data.txt, lang: text)
\end{codelisting}
We can open the file and read all lines from the file as follows:
%= lang:julia
\begin{code}
datafilename = "data.txt"
datafile = open(datafilename)
data = readlines(file)
close(datafile)
\end{code}
\noindent Then \kode{data} is an array with each line being an element. Since \kode{data} contains what we need, we close the file.
%= lang:julia
\begin{code}
julia> data
3-element Array{Union(ASCIIString,UTF8String),1}:
 "This is the first line.\n"
 "This is the second line.\n"
 "This is the third line."
\end{code}
\noindent We usually access each line in a for-loop:
%= lang:julia
\begin{code}
for line in data
	print(line)
	# process each line here...
end
\end{code}
\noindent Note that \kode{\textbackslash n} means a line change. Therefore we know that \kode{print("abc\textbackslash n")} is equivalent to \kode{println("abc")}. In the above example, if we put \kode{println(line)} instead of \kode{print(line)}, we will see an extra line between texts.




Writing the results to files is also similarly done.
%= lang:julia
\begin{code}
outputfilename = "results.txt"
outputfile = open(outputfilename, "w")
print(outputfile, "Magic Johnson")
println(outputfile, " is a basketball player.")
println(outputfile, "Michael Jordan is also a basketball player.")
close(outputfile)
\end{code}
\noindent The result looks like:
\begin{codelisting}
\codecaption{\filepath{code/chap3/results1.txt}}
%= <<(code/chap3/results1.txt, lang: text)
\end{codelisting}

By using \kode{"a"} option, we can append to the existing file:
%= lang:julia
\begin{code}
outputfilename = "results.txt"
outputfile = open(outputfilename, "a")
println(outputfile, "Yuna Kim is a figure skating player.")
close(outputfile)
\end{code}
The result will read:
\begin{codelisting}
\codecaption{\filepath{code/chap3/results2.txt}}
%= <<(code/chap3/results2.txt, lang: text)
\end{codelisting}



\begin{figure}
\imagebox{images/basics/simple_network.pdf}
\caption{A simple network\label{fig:example_net}}
\end{figure}


The most important data format may be comma-separated-values files, called CSV files. Data in each line is separated by commas. For example, consider the simple network presented in Figure \ref{fig:example_net}. This network may be represented as the following tabular data:

\begin{center}
\begin{tabular}{|r|r|r|}
\hline
start node & end node & link length \\
\hline
1 & 2 & 3\\
1 & 3 & 4.5\\
2 & 3 & 6 \\
2 & 4 & 3 \\
3 & 4 & 5 \\
\hline
\end{tabular}
\end{center}
In spreadsheet software like Excel, you can enter as follows
\begin{center}
\imagebox{images/basics/excel_csv.png}
\end{center}
and save it as `data.csv'. When you save it in Excel, you need to choose `Windows Comma Separated (.csv)', instead of just `Comma Separated Values (.csv)'. CSV files are basically text files. The saved data.csv file will look like:
\begin{codelisting}
\codecaption{\filepath{code/chap3/data.csv}}
%= <<(code/chap3/data.csv, lang: text)
\end{codelisting}
We read this CSV file as follows:
%= lang:julia
\begin{code}
csvfilename = "data.csv"
csvdata = readcsv(csvfilename,  header=true)
data = csvdata[1]
header = csvdata[2]
\end{code}
\noindent With the \kode{header=true} option, we can separate the header from the data. We obtained \kode{data} as an array of \kode{Float64}:
%= lang:julia
\begin{code}
julia> data
5x3 Array{Float64,2}:
 1.0  2.0  2.0
 1.0  3.0  4.5
 2.0  3.0  6.0
 2.0  4.0  3.0
 3.0  4.0  5.0
\end{code}
\noindent Since the third column represents link length, the type of \kode{Float64} is fine. On the other hand, the first and second columns represent the node indices, which must be integers. We change the type:
%= lang:julia
\begin{code}
julia> start_node = int(data[:,1])
5-element Array{Int64,1}:
 1
 1
 2
 2
 3

julia> end_node = int(data[:,2])
5-element Array{Int64,1}:
 2
 3
 3
 4
 4

julia> link_length = data[:,3]
5-element Array{Float64,1}:
 2.0
 4.5
 6.0
 3.0
 5.0
\end{code}

After some computation, suppose we obtained the following result:
%= lang:julia
\begin{code}
value1 = [1.4; 3.1; 5.3; 2.7]
value2 = [4.3; 7.0; 3.6; 6.2]
\end{code}
\noindent which we want to save in the following format:
\begin{center}
\begin{tabular}{|r|r|r|}
\hline
node & first value & second value \\
\hline
1 & 1.4 & 4.3\\
2 & 3.1 & 7.0\\
3 & 5.3 & 3.6\\
4 & 2.7 & 6.2\\
\hline
\end{tabular}
\end{center}
We can simply write the values on a file in the format we want:
%= lang:julia
\begin{code}
resultfile = open("result.csv", "w")
println(resultfile, "node, first value, second value")
for i in 1:length(value1)
	println(resultfile, "$i, $(value1[i]), $(value2[i])")
end
close(resultfile)
\end{code}
\noindent The result file looks like:
\begin{codelisting}
\codecaption{\filepath{code/chap3/result.csv}}
%= <<(code/chap3/result.csv, lang: text)
\end{codelisting}








\section{Plotting} \label{sec:plotting}

As \julia{} is still in its early stage, plotting---and installing packages for plotting---is not very straightforward. There are however two pretty stable options: \kode{Gadfly.jl} and \kode{PyPlot.jl}. The \kode{Gadfly.jl} package is a Julia native plotting package that rely on some other open-source libraries. On the other hand, the \kode{PyPlot.jl} package calls a Python module \kode{matplotlib.pyplot}, which means that you need to install Python and matplotlib in your computer. If you need a simple tool, select \kode{Gadfly.jl}; if you need a powerful tool, select \kode{PyPlot.jl}. The power of PyPlot comes in at the cost of installing Python. Read \href{https://en.wikibooks.org/wiki/Introducing_Julia/Plotting}{this Wiki page}\footnote{\url{https://en.wikibooks.org/wiki/Introducing_Julia/Plotting}} for an introduction.

At this moment, I find \kode{PyPlot.jl} provides more powerful plotting tools that are suitable for generating plots for academic research papers---yes, Python has been around for a while. It just comes at the cost of installing additional software packages.

\subsection{\kode{PyPlot.jl}} \label{sec:pyplot}

To use PyPlot, you need Python and matplotlib. The Anaconda Python is an easy-to-install distribution of Python and matplotlib (and many other python packages). If you have installed \kode{IJulia} as introduced in Section \ref{sec:ijulia}, you don't need to install the Anaconda Python again. Just install the \kode{PyPlot.jl} package.

\begin{enumerate}
\item Download and install \href{https://www.continuum.io/downloads}{the Anaconda Python 2.7}.\footnote{\url{https://www.continuum.io/downloads}}
\item Open a new terminal window and run Julia. Install PyPlot:
%= lang: julia
\begin{code}
Pkg.add("PyPlot")
\end{code}
\end{enumerate}


An example is given below:
\begin{codelisting}
\codecaption{\filepath{code/chap3/plot1.jl}}
%= <<(code/chap3/plot1.jl, lang: julia)
\end{codelisting}

In the first time of using PyPlot, it will take some time to precompile. In the above code, \kode{L} in \kode{"value of \$x\$"} means that the string inside the quotation marks will be \LaTeX{} strings. When you have dollar signs (\$) inside \kode{L"..."}, it is a combination of text and math symbols; when you don't, like as in \kode{L"\textbackslash sin(3x)"}, the entire text consists of math symbols only. The result is presented in Figure \ref{fig:myplot1}.

\begin{figure}
\image{images/basics/myplot1.pdf}
\caption{Result of \kode{plot1.jl} \label{fig:myplot1}}
\end{figure}

For another example, suppose that you obtained lower bounds and upper bounds from iterations of an algorithm. Then you want to put these two data in a single plot.
\begin{codelisting}
\codecaption{\filepath{code/chap3/plot2.jl}}
%= <<(code/chap3/plot2.jl, lang: julia)
\end{codelisting}

The result is in Figure \ref{fig:plot2}.

\begin{figure}
\image{images/basics/plot2.pdf}
\caption{Result of \kode{plot2.jl} \label{fig:plot2}}
\end{figure}

One can also create a histogram easily.
\begin{codelisting}
\codecaption{\filepath{code/chap3/plot3.jl}}
%= <<(code/chap3/plot3.jl, lang: julia)
\end{codelisting}

The result is in Figure \ref{fig:plot3}.

\begin{figure}
\image{images/basics/plot3.pdf}
\caption{Result of \kode{plot3.jl} \label{fig:plot3}}
\end{figure}





Many examples and sample codes for using \kode{PyPlot.jl} are provided in the following link:
\begin{itemize}
\item \href{https://gist.github.com/gizmaa/7214002}{Various Julia plotting examples using PyPlot}\footnote{\url{https://gist.github.com/gizmaa/7214002}}
\end{itemize}
Since \kode{PyPlot.jl} calls functions from \kode{matplotlib}, the following documents are also helpful.
\begin{itemize}
\item \href{http://matplotlib.org/users/beginner.html}{Matplotlib Beginner's Guide}\footnote{\url{http://matplotlib.org/users/beginner.html}}
\item \href{http://matplotlib.org/examples/index.html}{Matplotlib Examples}\footnote{\url{http://matplotlib.org/examples/index.html}}
\end{itemize}









\subsection{Avoiding Type-3 Fonts in \kode{PyPlot.jl}}

Some journal submission systems don't like PDF files saved by matplotlib. It is usually because the system cannot handle some newer font styles, Type-3 fonts. There are two ways:

\begin{itemize}
\item \textbf{Method 1. Using options of \kode{matplotlib}:}
We can specifically tell matplotlib to avoid Type-3 fonts as explained in \href{http://nerdjusttyped.blogspot.com/2010/07/type-1-fonts-and-matplotlib-figures.html}{this link}.\footnote{\url{http://nerdjusttyped.blogspot.com/2010/07/type-1-fonts-and-matplotlib-figures.html}} Create a file called \kode{matplotlibrc} (without any extension in the filename) and place it in the same directory as the Julia script. Put the following commands in the \kode{matplotlibrc} file:
%= lang:julia
\begin{code}
ps.useafm           : True
pdf.use14corefonts  : True
text.usetex         : True
\end{code}

\item \textbf{Method 2. Using the \kode{pgf} package of \LaTeX{}:}
Instead of using the command \kode{savefig("myplot.pdf")}, one can use \kode{savefig("myplot.pgf")}, which will save the figure as a set of \LaTeX{} commands that uses the \kode{pgf} package. Then use the following command to include the figure in the main \LaTeX{} document:
%= lang:tex
\begin{code}
\begin{figure} \centering
\resizebox{0.7\textwidth}{!}{\input{myplot.pgf}}
\caption{Figure caption goes here..}
\label{fig:myplot}
\end{figure}
\end{code}
Don't forget to include \kode{\textbackslash usepackage{pgf}} in the preamble of your main \LaTeX{} document.

\end{itemize}







\subsection{\kode{Gadfly.jl}}

As \kode{Gadfly.jl} is a Julia-native package---well with some external libraries that are easily installed within Julia---it is relatively simple to install. Install and test as follows:
%= lang: julia
\begin{code}
Pkg.add("Gadfly")
using Gadfly
plot(x=collect(1:100), y=sort(rand(100)),
     Guide.XLabel("Index"), Guide.YLabel("Step"))
\end{code}
\noindent It will open your web browser and output an SVG image.

To save a plot as a PNG file:
%= lang: julia
\begin{code}
using Gadfly
myplot = plot(x=collect(1:100), y=sort(rand(100)),
              Guide.XLabel("Index"), Guide.YLabel("Step"))
draw( PNG("myplot.png", 6inch, 3inch), myplot )
\end{code}

Sometimes, we want to save the plot as a PDF file, especially when we want to embed plots in \LaTeX{} documents. Install \kode{Cairo.jl} and use the following code:
%= lang: julia
\begin{code}
Pkg.add("Cairo")
using Gadfly
myplot = plot(x=collect(1:100), y=sort(rand(100)),
              Guide.XLabel("Index"), Guide.YLabel("Step"))
draw( PDF("myplot.pdf", 6inch, 3inch), myplot )
\end{code}

Read the \href{http://gadflyjl.org/}{Gadfly manual}.\footnote{\url{http://gadflyjl.org/}}
