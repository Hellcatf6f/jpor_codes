\chapter{Simple Linear Optimization} \label{chap:simple}

\section{Linear Programming (LP) Problems}

Once you have installed the \jump{} package and an optimization solver such as \texttt{Clp/Cbc}, \gurobi{}, or \cplex{}, we can have \julia{} to solve linear programming (LP) and mixed integer linear programming (MILP) problems easily. For example, consider the following LP problem:
\[
	\max \quad x_1 + 2x_2 + 5x_3
\]
subject to
\begin{align*}
-x_1 + x_2 + 3x_3 &\leq -5 \\
x_1 + 3x_2 - 7x_3 &\leq 10 \\
0 \leq x_1 &\leq 10 \\
x_2 &\geq 0 \\
x_3 &\geq 0 .
\end{align*}
Using \julia{} and \jump{}, we can write the following code:
\begin{codelisting}
\codecaption{LP Example 1 \\ \filepath{code/chap2/LP1.jl}}
%= <<(code/chap2/LP1.jl, lang: julia)
\end{codelisting}

If you are ineligible to use a free license of Gurobi, use the following code for the first part:
%= lang: julia
\begin{code}
using JuMP, Cbc
m = Model(solver=CbcSolver())
\end{code}
\noindent \kode{Cbc} can handle mixed integer linear programming problems.


The above code is pretty much self-explanatory, but here are some explanations. We first declare a placeholder for an optimization model:
%= lang:julia
\begin{code}
m = Model(solver=GurobiSolver())
\end{code}
\noindent where we also indicated that we want to use the \gurobi{} optimization solver. We call the model \texttt{m}.

We declare three variables:
%= lang:julia
\begin{code}
@defVar(m, 0<= x1 <=10)
@defVar(m, x2 >= 0)
@defVar(m, x3 >= 0)
\end{code}
\noindent where we used `macros' from the \jump{} packaged, \texttt{@defVar}. In \julia{}, macros do repeated jobs for you. It is somewhat similar to `functions' with some important differences. Refer to the \href{http://docs.julialang.org/en/latest/manual/metaprogramming/#macros}{official documentation}\footnote{\url{http://docs.julialang.org/en/latest/manual/metaprogramming/#macros}}.

Using another macro \texttt{@setObjective}, we set the objective:
%= lang:julia
\begin{code}
@setObjective(m, Max, x1 + 2x2 + 5x3)
\end{code}

Two constraints are added by the \texttt{@addConstraint} macro:
%= lang:julia
\begin{code}
@addConstraint(m, constraint1, -x1 +  x2 + 3x3 <= -5)
@addConstraint(m, constraint2,  x1 + 3x2 - 7x3 <= 10)
\end{code}
\noindent Note that \texttt{constraint1} and \texttt{constraint2} are the names of those constraints. These names will be useful for obtaining the corresponding dual variable values.

We are now ready with the optimization problem. If you like you can print the optimization model and check how it is written, the code is as simple as:
%= lang:julia
\begin{code}
print(m)
\end{code}
\noindent We solve the optimization problem:
%= lang:julia
\begin{code}
solve(m)
\end{code}

After solving the optimization problem, we can obtain the values of variables at the optimality by using the \texttt{getValue} function:
%= lang:julia
\begin{code}
println("Optimal Solutions:")
println("x1 = ", getValue(x1))
println("x2 = ", getValue(x2))
println("x3 = ", getValue(x3))
\end{code}
\noindent where \texttt{println} is a function that puts some text in a line on the screen. If you don't want to change the line after you print the text, use the \texttt{print} function instead.

Values of dual variables at the optimality can be obtained by calling the \texttt{getDual} functions with the corresponding constraint names:
%= lang:julia
\begin{code}
println("Dual Variables:")
println("dual1 = ", getDual(constraint1))
println("dual2 = ", getDual(constraint2))
\end{code}


In my machine, the output by \gurobi{} looks like:
%= lang:console
\begin{code}
julia> include("LP1.jl")
Max x1 + 2 x2 + 5 x3
Subject to
 -x1 + x2 + 3 x3 ≤ -5
 x1 + 3 x2 - 7 x3 ≤ 10
 0 ≤ x1 ≤ 10
 x2 ≥ 0
 x3 ≥ 0
Optimize a model with 2 rows, 3 columns and 6 nonzeros
Coefficient statistics:
  Matrix range    [1e+00, 7e+00]
  Objective range [1e+00, 5e+00]
  Bounds range    [1e+01, 1e+01]
  RHS range       [5e+00, 1e+01]
Presolve time: 0.00s
Presolved: 2 rows, 3 columns, 6 nonzeros

Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    9.0000000e+30   1.250000e+30   9.000000e+00      0s
       2    1.9062500e+01   0.000000e+00   0.000000e+00      0s

Solved in 2 iterations and 0.00 seconds
Optimal objective  1.906250000e+01
Optimal Solutions:
x1 = 10.0
x2 = 2.1875
x3 = 0.9375
Dual Variables:
dual1 = 1.8124999999999998
dual2 = 0.06249999999999989
\end{code}
\noindent If you want to use the \cplex{} optimization solver instead of \gurobi{}, change lines 3 and 6 as follows:
%= lang:julia
\begin{code}
using CPLEX
m = Model(solver=CplexSolver())
\end{code}
\noindent There are many other optimization solvers supported by the \jump{} package. See \href{http://jump.readthedocs.org/en/latest/installation.html#jump-solvertable}{the manual of JuMP} for a list.\footnote{\url{http://jump.readthedocs.org/en/latest/installation.html#jump-solvertable}}

\section{Alternative Ways of Writing LP Problems}

We can use arrays to define variables. For the same LP problem as in the previous section, we can write a \julia{} code alternatively as follows:



To define the variable $\vect{x}$ as a three-dimensional vector, we can write:
%= lang:julia
\begin{code}
@defVar(m, x[1:3] >= 0)
\end{code}
\noindent where \texttt{1:3} means an array with numbers from 1 to 3 (incrementing by 1).

Then we prepare a column vector $\vect{c}$ and use it for defining the objective function:
%= lang:julia
\begin{code}
c = [1; 2; 5]
@setObjecitve(m, Max, sum{ c[i]*x[i], i=1:3})
\end{code}
\noindent which is essentially same as:
\[
	\max \sum_{i=1}^3 c_i x_i
\]

In LP problems, constraints are usually written in the vector-matrix notation as $	\mat{A} \vect{x} \leq \vect{b} $. Following this convention, we prepare a matrix $\mat{A}$ and a vector $\vect{b}$, and use them for adding constraints:
%= lang:julia
\begin{code}
A = [-1  1  3;
      1  3 -7]
b = [-5; 10]
@addConstraint(m, constraint1, sum{ A[1,i]*x[i], i=1:3} <= b[1] )
@addConstraint(m, constraint2, sum{ A[2,i]*x[i], i=1:3} <= b[2] )
\end{code}
\noindent This will be impractical, if we have 100 constraints, instead of just 2. Alternatively, we can write:
%= lang:julia
\begin{code}
@defConstrRef constraint[1:2]
for j=1:2
    @addConstraint(m, constraint[j], sum{A[j,i]*x[i], i=1:3} <= b[j])
end
\end{code}
\noindent Even better, we can also write:
%= lang:julia
\begin{code}
@addConstraint(m, constraint[j=1:2], sum{A[j,i]*x[i], i=1:3 } <= b[j])
\end{code}
\noindent Use any form that works for you. The \texttt{JuMP} package provides many different methods of adding constraints. Read \href{http://jump.readthedocs.org/en/latest/refexpr.html}{the official document}.\footnote{\url{http://jump.readthedocs.org/en/latest/refexpr.html}}

Finally, we add the bound constraint on $x_1$:
%= lang:julia
\begin{code}
@addConstraint(m, bound, x[1] <= 10)
\end{code}

The final code is presented:
\begin{codelisting}
\codecaption{LP Example 2 \\ \filepath{code/chap2/LP2.jl}}
%= <<(code/chap2/LP2.jl, lang: julia)
\end{codelisting}

Note that there have been changes in the code for printing. The result looks like:
%= lang:console
\begin{code}
julia> include("LP2.jl")
Max x[1] + 2 x[2] + 5 x[3]
Subject to
 -x[1] + x[2] + 3 x[3] ≤ -5
 x[1] + 3 x[2] - 7 x[3] ≤ 10
 x[1] ≤ 10
 x[i] ≥ 0 for all i in {1,2,3}
Optimal Solutions:
x[1] = 10.0
x[2] = 2.1875
x[3] = 0.9375
Dual Variables:
dual[1] = 1.8124999999999998
dual[2] = 0.06249999999999989
\end{code}



\section{Yet Another Way of Writing LP Problems}

In \texttt{LP2.jl}, we used \texttt{1:3} for indices for $x_i$ and \texttt{1:2} for indices of constraints. If you want to change the data and solve another problem with the same structure, then you will have to change the numbers 3 and 2 manually, which of course is very tedious and most likely create unwanted bugs. Instead, we can assign names for those sets of indices:
%= lang:julia
\begin{code}
index_x = 1:3
index_constraints = 1:2
\end{code}
\noindent Then, you can rewrite the code for adding constraints, for example:
%= lang:julia
\begin{code}
@addConstraint(m, constraint[j in index_constraints],
                  sum{ A[j,i]*x[i], i in index_x } <= b[j] )
\end{code}
\noindent The complete code would look like:
\begin{codelisting}
\codecaption{LP Example 3 \\ \filepath{code/chap2/LP3.jl}}
%= <<(code/chap2/LP3.jl, lang: julia)
\end{codelisting}

The result of \texttt{LP3.jl} should be same of that of \texttt{LP2.jl}.




\section{Mixed Integer Linear Programming (MILP) Problems}

In many applications, variables are often binary or discrete; the resulting optimization problem then becomes an integer programming problem. Further if everything is linear and there are both continuous variables and integer variables, the optimization problem is called a mixed integer linear programming (MILP) problems. The \gurobi{} and \cplex{} optimization solvers can handle this type of problems very well.

Suppose now $x_2$ is an integer variable and $x_3$ is a binary variable in the previous LP problem. That is:
\[
	\max \quad x_1 + 2x_2 + 5x_3
\]
subject to
\begin{align*}
-x_1 + x_2 + 3x_3 &\leq -5 \\
x_1 + 3x_2 - 7x_3 &\leq 10 \\
0 \leq x_1 &\leq 10 \\
x_2 &\geq 0 \text{ Integer }\\
x_3 &\in \{0, 1\} .
\end{align*}
Using \jump{}, it is very simple to specify integer and binary variables. We can define variables as follows:
%= lang:julia
\begin{code}
@defVar(m, 0<= x1 <=10)
@defVar(m, x2 >=0, Int)
@defVar(m, x3 >=0, Bin)
\end{code}

The complete code would look like:
\begin{codelisting}
\codecaption{MILP Example 1 \\ \filepath{code/chap2/MILP1.jl}}
%= <<(code/chap2/MILP1.jl, lang: julia)
\end{codelisting}
The result looks like:
%= lang:console
\begin{code}
julia> include("MILP1.jl")
Max x1 + 2 x2 + 5 x3
Subject to
 -x1 + x2 + 3 x3 ≤ -5
 x1 + 3 x2 - 7 x3 ≤ 10
 0 ≤ x1 ≤ 10
 x2 ≥ 0, integer
 x3 in {0,1}
Optimize a model with 2 rows, 3 columns and 6 nonzeros
Coefficient statistics:
  Matrix range    [1e+00, 7e+00]
  Objective range [1e+00, 5e+00]
  Bounds range    [1e+00, 1e+01]
  RHS range       [5e+00, 1e+01]
Found heuristic solution: objective 15
Presolve time: 0.00s
Presolved: 2 rows, 3 columns, 6 nonzeros
Variable types: 1 continuous, 2 integer (1 binary)

Root relaxation: objective 1.900000e+01, 0 iterations, 0.00 seconds

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

*    0     0               0      19.0000000   19.00000  0.00%     -    0s

Explored 0 nodes (0 simplex iterations) in 0.00 seconds
Thread count was 2 (of 4 available processors)

Optimal solution found (tolerance 1.00e-04)
Best objective 1.900000000000e+01, best bound 1.900000000000e+01, gap 0.0%
Optimal Solutions:
x1 = 10.0
x2 = 2.0
x3 = 1.0
\end{code}
